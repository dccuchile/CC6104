%\documentclass[mathserif]{beamer}
\documentclass[handout]{beamer}
%\usetheme{Goettingen}
\usetheme{Warsaw}
%\usetheme{Singapore}
%\usetheme{Frankfurt}
%\usetheme{Copenhagen}
%\usetheme{Szeged}
%\usetheme{Montpellier}
%\usetheme{CambridgeUS}
%\usecolortheme{}
%\setbeamercovered{transparent}
\usepackage[english, activeacute]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath, amssymb}
\usepackage{dsfont}
\usepackage{graphics}
\usepackage{cases}
\usepackage{graphicx}
\usepackage{pgf}
\usepackage{epsfig}
\usepackage{amssymb}
\usepackage{multirow}	
\usepackage{amstext}
\usepackage[ruled,vlined,lined]{algorithm2e}
\usepackage{amsmath}
\usepackage{epic}
\usepackage{epsfig}
\usepackage{fontenc}
\usepackage{framed,color}
\usepackage{palatino, url, multicol}
\usepackage{listings}
%\algsetup{indent=2em}
\newcommand{\factorial}{\ensuremath{\mbox{\sc Factorial}}}
\newcommand{\BIGOP}[1]{\mathop{\mathchoice%
{\raise-0.22em\hbox{\huge $#1$}}%
{\raise-0.05em\hbox{\Large $#1$}}{\hbox{\large $#1$}}{#1}}}
\newcommand{\bigtimes}{\BIGOP{\times}}
\vspace{-0.5cm}
\title{Introduction to R}
\vspace{-0.5cm}
\author[Felipe Bravo Márquez]{\footnotesize
%\author{\footnotesize  
 \textcolor[rgb]{0.00,0.00,1.00}{Felipe José Bravo Márquez}} 


\date{ \today }


\begin{document}
\begin{frame}
\titlepage


\end{frame}


%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Introduction}




\begin{frame}{The R project for computational statistics}
\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.6]{pics/Rlogo.png}
\end{figure}
\scriptsize{
\begin{itemize}
 \item R is a free statistical programming environment: \url{http://www.r-project.org/}
 \item It allows to manipulate and store data in an effective way.
 \item R is a complete programming language: variables, loops, conditions, functions.
 \item It provides many libraries that implement pretty much any statistical method.
 \item These libraries together with their dependencies are organized in a repository called \textbf{CRAN}: \url{http://cran.r-project.org/}



\end{itemize}

}



\end{frame}


\begin{frame}{Why use R?}


\scriptsize{
\begin{itemize}
 \item R is free software unlike Matlab, SPSS, STATA.
 \item It is available for many operating systems: Windows, MAC OS X, Linux.
 \item As of 2013 \textbf{KDnuggets} survey showed R as the preferred programming language for performing data analysis, data mining and data science.
 \item \url{http://www.kdnuggets.com/2013/08/languages-for-analytics-data-mining-data-science.html}
 \item Today Python has become a very strong competitor.


\end{itemize}

}

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.3]{pics/rpoll.png}
\end{figure}


\end{frame}

\begin{frame}{RStudio}
\scriptsize{
\begin{itemize}
  \item R works through the command line.
 \item To work in a more friendly environment we will use RStudio.
 \item It is also free and can be downloaded for different operating systems at this link: \url{http://www.rstudio.com/ide/download/desktop}
\end{itemize}

} 

\begin{figure}[h!]
	\centering
	\includegraphics[scale=0.2]{pics/rstudio.png}
\end{figure}

 
\end{frame}


\section{R basic commands}

\begin{frame}[fragile]{R as a calculator}
\begin{verbatim}
> 4*5
[1] 20
> 2^3
[1] 8
> exp(-5)
[1] 0.006737947
> log(4)
[1] 1.386294
\end{verbatim}

\footnotemark{The following slides are based on \cite{venables2009introduction}}
 
\end{frame}




\begin{frame}[fragile]{Declaring Variables}
\scriptsize{
\begin{itemize}
 \item Variables can be assigned using \verb+<-+ , \verb+=+ or the function \verb+assign+.
 
  \begin{verbatim}
a<-1
b=3
assign("three",3)
d<-a+b
ver<-T # equivalent to TRUE
word<-"hello"
\end{verbatim}
 
 \item By convention we use the first form (\verb+<-+).
 
\item Variables can be of class \textbf{numeric}, \textbf{factor}, \textbf{character}, \textbf{logical}, among others.
 
\item To see the type of a variable we use the command \verb+class+.
 \begin{verbatim}
  > class(a) 
[1] "numeric"
> class(ver)
[1] "logical"
> class(word)
[1] "character"
 \end{verbatim}

 
 
\end{itemize}

}


\end{frame}


\begin{frame}[fragile]{Functions}
\scriptsize{
\begin{itemize}
 \item Functions are declared as variables and are created with the expression \textbf{function}:

\begin{verbatim}
suma<-function(a=2,b=1){
  a+b;
}

fac<-function(n){
  ifelse(n==1,return(1),return(n*fac(n-1)))    
}

\end{verbatim}

\item Function parameters can be declared with a specific value to be used as default values when we do not provide values for those parameters:
\begin{verbatim}
> suma(3,4)
[1] 7
> suma()
[1] 3
 
\end{verbatim}

\item The functions are of the type \textbf{function}:
\begin{verbatim}
> class(suma)
[1] "function" 
\end{verbatim}


\end{itemize}


 
} 
\end{frame}

\begin{frame}[fragile]{Help and Workspace}
\scriptsize{
\begin{itemize}
 \item To read documentation about a function we use either \textbf{help} or \textbf{?}:
\begin{verbatim}
help(ls)
?ls
#for a particular command
help("for")
\end{verbatim}

\item All variables are stored in my \textbf{workspace} environment. To list them we use the command \textbf{objects} or \textbf{ls}. To delete a variable we use \textbf{rm}:

\begin{verbatim}
objects()
ls()
rm(a)
#Para borrarlos todos
rm(list=ls())
 
\end{verbatim}


\item I can save all my workspace variables in a file and then retrieve my work in a future session:
\begin{verbatim}
save.image("myworkspace.RData")
#Luego lo cargamos
load("myworkspace.RData")
 
\end{verbatim}


 
 
 
 \end{itemize}



}
 
 
\end{frame}

\begin{frame}[fragile]{Vectors}
\scriptsize{
\begin{itemize}
 \item To work with collections of elements we declare \textbf{vectors} which are constructed with the command \textbf{c}:
 \begin{verbatim}
edades<-c(21,33,12,34,23,70,90,80,7,29,14,2,
          88,11,55,24,13,11,56,28,33)
 \end{verbatim}
 \item To get the length of a vector we use the command \textbf{length}, then to get the sum of all elements we use \textbf{sum}:
 \begin{verbatim}
> suma<-sum(edades)
> largo<-length(edades)
> suma
[1] 734
> largo
[1] 21
 \end{verbatim}
 
\item If we operate a vector by a scalar this value is recycled for all elements of the vector:
 \begin{verbatim}
> numeros<-c(1,2,3)
> numeros+3
[1] 4 5 6
> numeros*5
[1]  5 10 15
 \end{verbatim}
\end{itemize}




}
 
 
\end{frame}

\begin{frame}[fragile]{Vectors (2)}
\scriptsize{
\begin{itemize}
 \item Calculate the mean and variance of the vector ages using the commands \textbf{sum} and \textbf{length} based on the following equations:
 \begin{equation}
  \text{mean}(\text{edades})=\frac{\sum_{i=1}^n\text{edades}_{i}}{n}
 \end{equation}
 
 \begin{equation}
 \text{variance}(\text{edades})=\frac{\sum_{i=1}^n(\text{edades}_{i}-\text{media}(\text{edades}))^2 }{n-1} 
 \end{equation}

 
\end{itemize}



}

 
\end{frame}



\begin{frame}[fragile]{Vectors (3)}
\scriptsize{
\begin{itemize}
 \item Answer:
 \begin{verbatim}
> media<-sum(edades)/length(edades)
> media
[1] 34.95238
> varianza<-sum((edades-media)^2)/(length(edades)-1)
> varianza
[1] 747.9476
 \end{verbatim}
 
 \item R has \textbf{mean} and \textbf{var} functions:
 \begin{verbatim}
> mean(edades)
[1] 34.95238
> var(edades)
[1] 747.9476

 \end{verbatim}
 
\end{itemize}



}

 
\end{frame}
 
 
\begin{frame}[fragile]{Vectors (4)}
\scriptsize{
\begin{itemize}
 
\item When we construct vectors with elements of different types, R converts them all to a single type:
\begin{verbatim}
> c("hola",2,T)
[1] "hola" "2"    "TRUE"
> c(TRUE,FALSE,500)
[1]   1   0 500 
\end{verbatim}

 \item The elements of a vector can be declared with names and then retrieved with the \textbf{names} command:
\begin{verbatim}
> notas<-c(Juan=4.5,Luis=6.2,Romina=3.9,Felipe=2.8,Mariana=6.7)
> names(notas)
[1] "Juan"    "Luis"    "Romina"  "Felipe"  "Mariana"
 
\end{verbatim}
\item We can sort a vector using the \textbf{sort} command:
\begin{verbatim}
> names(sort(x=notas,decreasing=T))
[1] "Mariana" "Luis"    "Juan"    "Romina"  "Felipe" 
\end{verbatim}

\end{itemize}



}
\end{frame}

\begin{frame}[fragile]{Vector Access}
\scriptsize{
\begin{itemize}

 \item R allows access to the elements of a vector by means of numerical indexes \verb+[i]+: 
\begin{verbatim}
> notas[1] # first element
Juan 
 4.5
\end{verbatim}

\item The index can be another numeric vector to access more than one element:
\begin{verbatim}
> notas[c(1,5)] # first and fifth element
   Juan Mariana 
    4.5     6.7 
\end{verbatim}

\item If we want to omit any element we use negative indexes:
\begin{verbatim}
> notas[-2] # All but the second one
   Juan  Romina  Felipe Mariana 
    4.5     3.9     2.8     6.7 
\end{verbatim}

\item The elements can also be accessed by their names:
\begin{verbatim}
> notas[c("Juan","Mariana")] # Only Juan and Mariana
   Juan Mariana 
    4.5     6.7 
\end{verbatim}



\end{itemize}

 

 }
\end{frame}


\begin{frame}[fragile]{Operating Vectors}
\scriptsize{
\begin{itemize}
 \item We saw earlier that if I operate a scalar by a vector, the scalar applies to all the elements of the vector.
 \item If I now have two vectors of the same length and operate on them, the operation is done element by element (element-wise):
\begin{verbatim}
a<-c(1,2)
b<-c(3,4)
> a+b
[1] 4 6
> a*b
[1] 3 8
\end{verbatim}

\end{itemize}
 }
\end{frame}



\begin{frame}[fragile]{Operating Vectors (2)}
\scriptsize{
\begin{itemize}
\item If the vectors are of different lengths, the smaller one recycles its elements:
\begin{verbatim}
> d<-c(4,5,6,9)
> a+d
[1]  5  7  7 11
> c(a,a)+d
[1]  5  7  7 11
\end{verbatim}

\item If the length of the longest is not a multiple of the length of the shortest, we get a warning:
\begin{verbatim}
> c(1,2)+c(-9,2,3)
[1] -8  4  4
Warning message:
In c(1, 2) + c(-9, 2, 3) :
  longer object length is not a multiple of shorter object length 
\end{verbatim}
 
\end{itemize}
 }
\end{frame}



\begin{frame}[fragile]{Comparing Vectors}
\scriptsize{
\begin{itemize}
 \item R supports the comparison operators for numeric variables:\verb+ >,<, ==, <=, >=, !=+ in addition to \verb+& |+ as well as the operators \textbf{and} and \textbf{or} for logical variables:
\begin{verbatim}
> menores<-edades<18
> menores
 [1] FALSE FALSE  TRUE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE  TRUE  TRUE FALSE  TRUE FALSE FALSE
[17]  TRUE  TRUE FALSE FALSE FALSE
\end{verbatim}
\item If we give a vector an index of logical variables we retrieve the values where the index takes the true value: 
\begin{verbatim}
> edades[menores] 
[1] 12  7 14  2 11 13 11
\end{verbatim}

\item Exercise: calculate the average age of the elements older or equal to 18 years old.
\begin{verbatim}
mean(edades[edades>=18]) 
\end{verbatim}

 
\end{itemize}



}
\end{frame}

\begin{frame}[fragile]{Null Values}
\scriptsize{
\begin{itemize}
\item In R, missing values are written as \verb+NA+. It is common that they appear when we read data from a database. Some functions do not accept null values so they must be taken into account.
\begin{verbatim}
> missing_vector<-c(12,15,NA)
> missing_vector
[1] 12 15 NA
\end{verbatim}

\item To check if a variable is null we use the command \verb+is.na+:
\begin{verbatim}
> missing_vector[!is.na(missing_vector)]
[1] 12 15 
\end{verbatim}



\end{itemize}

 }
 
 
\end{frame}




\begin{frame}[fragile]{Secuencias}
 \scriptsize{
 
 \begin{itemize}
  \item To create a vector consisting of a sequence of numbers we use the command \textbf{seq}:
 
 \begin{verbatim}
> pares<-seq(from=2,to=20,by=2)
> cuatro_mult<-seq(from=4,by=4,length=100)
> pares
 [1]  2  4  6  8 10 12 14 16 18 20
 \end{verbatim} 
 \item It can also be created using the operator (\verb+:+):
 \begin{verbatim}
> 1:10
 [1]  1  2  3  4  5  6  7  8  9 10 
> seq(1,10,1)
 [1]  1  2  3  4  5  6  7  8  9 10
 \end{verbatim} 
 \end{itemize}
 
 }
\end{frame}

\begin{frame}[fragile]{Repetitions}
\scriptsize{
\begin{itemize}
 \item To create vectors that repeat a value or another vector multiple times we use the command \textbf{rep}. The first value is the object to repeat and the second is the number of repetitions:
 \begin{verbatim}
> rep(10,3)
[1] 10 10 10
> rep(c("hello", "bye"),4)
[1] "hello" "bye" "hello" "bye" "hello" "bye"
"hello" "bye" "hello" "bye"
 \end{verbatim}
  \item Problem: Create a sequence that repeats 3 times the first 4 multiples of 7.
 \begin{verbatim}
> rep(seq(from=7,by=7,length=4),3)
 [1]  7 14 21 28  7 14 21 28  7 14 21 28
\end{verbatim}
 
 
\end{itemize}
 
 
 
} 
\end{frame}

\begin{frame}[fragile]{Random vector generation}
\scriptsize{
\begin{itemize}
 \item To perform experiments or simulate phenomena of known behavior it is very useful to generate random vectors.
 \item  If we want uniformly distributed numbers between a maximum and a minimum we use \textbf{runif}:
 \begin{verbatim}
> runif(n=5, min = 1, max = 10)
[1] 5.058862 1.737830 9.450956 9.149376 2.652774
 \end{verbatim}
 \item  If we want numbers centered on a mean $\mu$ with a standard deviation $\sigma$, we use a normal distribution with the command \textbf{rnorm} where we know that $68\%$  of the observationswill be within the range $\mu\pm\sigma$, $95\%$ in $\mu\pm2\sigma$ and $99.7\%$ in $\mu\pm3\sigma$:
 
 \begin{verbatim}
> rnorm(n=5, mean = 10, sd = 4)
[1] 12.081286  2.636001 16.001953  0.120463  6.211835
 \end{verbatim}
 
\end{itemize}

}
\end{frame}

\begin{frame}[fragile]{Random Vector Generation (2)}
\scriptsize{
\begin{itemize}
 \item When we want to model the number of arrivals per unit of time to simulate queuing models, we use the \textbf{Poisson} distribution with \textbf{rpos}. The parameter $\lambda$ tells us the average number of arrivals per time period
 \begin{verbatim}
> rpois(n=10, lambda = 3)
 [1] 1 3 8 6 1 1 6 3 4 7
 \end{verbatim}

 \item In a binomial distribution experiment we repeat $n$ times, where in each one we perform $k$ trials of a phenomenon whose probability of success in each trial is $p$.  We can simulate the number of hits obtained in each experimentWith the command \textbf{rbinom}.
\begin{verbatim}
> rbinom(n=10,size=2,prob=0.5)
 [1] 0 1 2 1 1 0 2 0 0 1
> rbinom(n=10,size=2,prob=0.7)
 [1] 1 2 2 1 0 1 2 2 2 2
> rbinom(n=10,size=2,prob=0.2)
 [1] 0 0 0 0 1 0 1 0 1 0 
\end{verbatim}

 
 
\end{itemize}


}
\end{frame}


\begin{frame}[fragile]{Variables Categóricas o Factores}
\scriptsize{
\begin{itemize}
 \item Además de las variables numéricas o lógicas, se puede trabajar con variables categóricas. Ej: color, sexo, clase social.
 \item Se crean con el comando \textbf{factor} y los posibles valores de la variable se guardan en el atributo \textbf{levels}.
\begin{verbatim}
> gente<-factor(c("Hombre","Mujer","Mujer","Mujer","Hombre"))
> gente
[1] Hombre Mujer  Mujer  Mujer  Hombre
Levels: Hombre Mujer
> class(gente)
[1] "factor"
> levels(gente)
[1] "Hombre" "Mujer" 
#Puedo renombrar a los niveles
> levels(gente)<-c("Man","Woman")
> gente
[1] Man   Woman Woman Woman Man  
Levels: Man Woman
\end{verbatim}
 
\end{itemize}

}
\end{frame}


\begin{frame}[fragile]{Agregando variables por categorías con \textbf{tapply}}
\scriptsize{
\begin{itemize}
 \item Si tenemos un vector numérico y otro categórico del mismo largo podemos aplicar una función de agregación.
 \item Ejemplo: Creo una categoría para el vector edades de niveles \emph{niño}, \emph{adolescente}, \emph{adulto}:
 \begin{verbatim}
categ_edades<-ifelse(edades<12,"niño",
                      ifelse(edades<18,"adolescente","adulto"))
class(categ_edades)
[1] "character"
#Convierto a factor con as.factor
categ_edades<-as.factor(categ_edades)
 \end{verbatim}

 \item Ahora cuento la cantidad de personas por categoría, y calculo la media y la desviación estándar para cada grupo:
\begin{verbatim}
tapply(edades,categ_edades,length)
adolescente      adulto        niño 
          3          14           4 
> tapply(edades,categ_edades,mean)
adolescente      adulto        niño 
   13.00000    47.42857     7.75000 
> tapply(edades,categ_edades,sd)
adolescente      adulto        niño 
   1.000000   25.294312    4.272002 
  
\end{verbatim}

 
\end{itemize}



}
\end{frame}


\begin{frame}[fragile]{Manejo de Strings}
\scriptsize{
 \begin{itemize}
  \item Puedo imprimir un string usando el comando \textbf{cat}:
\begin{verbatim}
> saludo<-"Hola Mundo"
> cat(saludo)
Hola Mundo
\end{verbatim}

\item Para concatenar dos strings uso el comando \textbf{paste}:
\begin{verbatim}
> paste("Hola","Chao",sep="-")
[1] "Hola-Chao"
> paste("persona",1:4, sep="")
[1] "persona1" "persona2" "persona3" "persona4"
> paste(saludo,1:3, sep=" ")
[1] "Hola Mundo 1" "Hola Mundo 2" "Hola Mundo 3" 
\end{verbatim}

\item Para extraer sub-cadenas usamos el comando \textbf{substr}:
\begin{verbatim}
> substr(saludo,1,4)
[1] "Hola" 
\end{verbatim}

\item Existe un vector llamado \textbf{letters} que tiene todas las letras del abecedario, útil para nombrar variables:
\begin{verbatim}
> letters[1:4]
[1] "a" "b" "c" "d" 
\end{verbatim}


 \end{itemize}

 }
\end{frame}


\begin{frame}[fragile]{Matrices}
\scriptsize{
 \begin{itemize}
  \item Las matrices son vectores de dos dimensiones. Por defecto se van llenando por columna:
 \begin{verbatim}
> matriz_por_col<-matrix(data=1:12,nrow=3,ncol=4)
> matriz_por_col
     [,1] [,2] [,3] [,4]
[1,]    1    4    7   10
[2,]    2    5    8   11
[3,]    3    6    9   12 
 \end{verbatim}
 \item Para llenarlas por fila uso el parámetro \textbf{byrow}:
 \begin{verbatim}
> matriz_por_fil<-matrix(data=1:12,nrow=4,ncol=3,byrow=T)
> matriz_por_fil
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
[3,]    7    8    9
[4,]   10   11   12  
 \end{verbatim}

 \item Accedemos a la dimensión de la matriz con el comando \textbf{dim}.
 \begin{verbatim}
 > dim(matriz_por_fil)
[1] 4 3 
 \end{verbatim}

 \end{itemize} 
 }
\end{frame}


\begin{frame}[fragile]{Matrices (2)}
\scriptsize{
 \begin{itemize}
  \item Para acceder a los elementos de una matriz tengo que especificar las filas $i$ y las columnas $j$ \verb+[i,j]+. Si dejo alguno de los dos valores vacío se recuperan todos las filas o columnas: 
 \begin{verbatim}
 > matriz_por_fil[2,] #Segunda fila, todas las columnas
[1] 4 5 6
> matriz_por_fil[2,1] # Segunda fila, primera columna
[1] 4
> matriz_por_fil[-1,-2] # Descarto fila 1 y columna 2
     [,1] [,2]
[1,]    4    6
[2,]    7    9
[3,]   10   12 
 \end{verbatim}
\item Para acceder a los nombres de las filas o columnas usamos \textbf{rownames} y \textbf{colnames} de forma análoga a como usamos \textbf{names} para los vectores.
\begin{verbatim}
> rownames(matriz_por_fil)<-paste("r",1:4,sep="")
> colnames(matriz_por_fil)<-paste("c",1:3,sep="")
> matriz_por_fil["r2","c3"]
[1] 6
\end{verbatim}  
 \end{itemize}
 }
\end{frame}


\begin{frame}[fragile]{Matrices (3)}
\scriptsize{
\begin{itemize}
 \item Puedo agregarle nuevas filas o nuevas columnas a una matriz usando \textbf{rbind} y \textbf{cbind} respectivamente:
 \begin{verbatim}
  > rbind(matriz_por_fil,r5=1:3)
   c1 c2 c3
r1  1  2  3
r2  4  5  6
r3  7  8  9
r4 10 11 12
r5  1  2  3
> cbind(matriz_por_fil,c4=4:1)
   c1 c2 c3 c4
r1  1  2  3  4
r2  4  5  6  3
r3  7  8  9  2
r4 10 11 12  1
 \end{verbatim}

\end{itemize}
 
 
 
} 
\end{frame}

\begin{frame}[fragile]{Matrices (4)}
\scriptsize{
\begin{itemize}
 \item Operaciones algebraicas como la multiplicación de matrices se hace con \verb+%*%+:
 \begin{verbatim}
>a<-matriz_por_col %*% matriz_por_fil
      c1  c2  c3
[1,] 166 188 210
[2,] 188 214 240
[3,] 210 240 270
 \end{verbatim}

 
\item  Si usamos solamente el operador \verb+*+, la multiplicación se hace elemento por elemento (sólo para matrices de igual dimensión). Esto aplica también para la suma, la resta, la división y otro tipo de operadores.

\end{itemize}


 
}

\end{frame}

\begin{frame}[fragile]{Matrices (5)}
\scriptsize{
\begin{itemize}
\item Podemos transponer una matriz con \textbf{t}:
 \begin{verbatim}
> t(a)
   [,1] [,2] [,3]
c1  166  188  210
c2  188  214  240
c3  210  240  270
\end{verbatim}
\item Los valores y vectores propios se calculan con \textbf{eigen}:
\begin{verbatim}
> eigen(a)
$values
[1] 6.483342e+02 1.665808e+00 3.437970e-14

$vectors
           [,1]        [,2]       [,3]
[1,] -0.5045331 -0.76077568  0.4082483
[2,] -0.5745157 -0.05714052 -0.8164966
[3,] -0.6444983  0.64649464  0.4082483
 \end{verbatim}

\end{itemize}


 
}

\end{frame}

\begin{frame}[fragile]{Arreglos o Tensores}
\scriptsize{
\begin{itemize}
 \item Los arreglos (o tensores) son como las matrices pero de más dimensiones:
 \begin{verbatim}
> arreglo<-array(1:8, dim=c(2,2,2))
> arreglo
, , 1

     [,1] [,2]
[1,]    1    3
[2,]    2    4

, , 2

     [,1] [,2]
[1,]    5    7
[2,]    6    8

> arreglo[1,2,1]
[1] 3
 \end{verbatim}

\end{itemize}


}
\end{frame}




\begin{frame}[fragile]{Listas}
\scriptsize{
\begin{itemize}
 \item Las matrices me restringen a que todos los vectores sean del mismo largo y del mismo tipo.
 \item Las listas me permiten agrupar objetos de cualquier tipo y de cualquier largo:
 \begin{verbatim}
milista<-list(hombre="Pepe",mujer="Juana",
              hijos=3,edades=c(4,8,12))
 \end{verbatim}
 \item Cuando accedo a sus elementos usando \verb+[i]+ recupero una sub-lista:
 \begin{verbatim}
> milista[c(3,4)] # Sublista
$hijos
[1] 3
$edades
[1]  4  8 12
 \end{verbatim}
\item Para acceder a una elemento particular tengo tres opciones:
\begin{verbatim}
milista[[1]]
milista[["hombre"]]
milista$hombre

[1] "Pepe"
\end{verbatim}


\end{itemize}



}
\end{frame}

\begin{frame}[fragile]{Ejercicio Lista}
\scriptsize{

\begin{itemize}
 \item Crear una lista que tenga tres vectores de largo 100  generado por alguno de los mecanismos vistos para generar vectores aleatorios. Pueden variar las distribuciones o los parámetros. Asígnele nombres a cada uno de los vectores. \pause
 \begin{verbatim}
 vectores<-list(normal=rnorm(n=100,mean=10,sd=5),
               poisson=rpois(n=100,lambda=10),
               uniforme=runif(n=100,min=5,max=15))
 \end{verbatim}

\item Calcule la media y la desviación estándar de cada uno de los vectores de la lista. \pause
\begin{verbatim}
medias<-vector()
desv<-vector()
for(i in 1:length(vectores)){
  medias[i]<-mean(vectores[[i]])
  desv[i]<-sd(vectores[[i]])
}
> medias
[1] 10.589222 10.390000  9.579866
> desv
[1] 5.155478 2.711349 2.905810
\end{verbatim}

 
\end{itemize}

}
\end{frame}

\begin{frame}[fragile]{Cálculos agregados a Listas con \textbf{sapply} y \textbf{lapply}}
 \scriptsize{
 \begin{itemize}
  \item El ejercicio anterior se puede resolver de manera mucho más sencilla en R con unas funciones especiales para realizar agregación sobre listas.
  \item El comando \textbf{sapply} permite aplicar una función a cada elemento de una lista y devuelve los resultados en un vector. Luego \textbf{lapply} hace lo mismo pero retorna una lista:
 \begin{verbatim}
 > sapply(vectores,mean)
   normal   poisson  uniforme 
10.589222 10.390000  9.579866 
> sapply(vectores,sd)
  normal  poisson uniforme 
5.155478 2.711349 2.905810  
 \end{verbatim}  

 \item Ejercicio, programar una propia versión de \textbf{sapply}. Hint: En R una funciones puede recibir otra  función como parámetro y aplicarla de manera genérica. \pause
\begin{verbatim}
 myapply<-function(lista,fun,...){
  resultado<-vector(length=length(lista))
  for(i in 1:length(lista)){
    resultado[i]<-fun(lista[[i]],...)
  }
  resultado  
}
\end{verbatim}
  
 \end{itemize}
 
 }
\end{frame}


\begin{frame}[fragile]{Data Frames}
\scriptsize{
\begin{itemize}
 \item El data.frame es el tipo de colección de datos más utilizada para trabajar con datasets en R.
 
 \item Un data.frame se compone de varios vectores, donde cada vector puede ser de distintos tipos, pero del mismo largo. Es equivalente a una tabla de una base de datos:
 \begin{verbatim}
edades.frame<-data.frame(edad=edades,categoria=categ_edades)

> edades.frame
   edad   categoria
1    21      adulto
2    33      adulto
3    12 adolescente
\end{verbatim}

\item Las dimensiones de un data.frame se acceden de la misma manera que en una matriz:
\begin{verbatim}
> length(edades.frame)
[1] 2
> dim(edades.frame)
[1] 21  2 
\end{verbatim}
 
\end{itemize}



}
\end{frame}

\begin{frame}[fragile]{Data Frames (2)}
\scriptsize{ 
\begin{itemize}
 \item Puedo acceder a los elementos como si fuese una matriz o una lista:
 \begin{verbatim}
> edades.frame[3,1] # La edad del tercer elemento
[1] 12
> edades.frame$edad[1:6] # La edad de los primeros 6 elementos
[1] 21 33 12 34 23 70
 \end{verbatim}
 
\item También puede pasar cada variable del data.frame a mi workspace con el comando \textbf{attach} y así accederlas directamente:
\begin{verbatim}
attach(edades.frame)
> categoria[1:3]
[1] adulto      adulto      adolescente
Levels: adolescente adulto niño
\end{verbatim}

\item Puedo guardar un data.frame en un archivo csv (separado por comas u otra carácter) usando \textbf{write.table}:
\begin{verbatim}
write.table(x=edades.frame,file="edades.csv",sep=",",row.names=F) 
\end{verbatim}

\item Pongo \verb+row.names=F+ para que no ponga los nombres de las columnas en el archivo.

 
\end{itemize}
 
}
\end{frame}


\begin{frame}[fragile]{Cargando Data Frames}
\scriptsize{
\begin{itemize}
 \item Puedo leer un data.frame desde archivos \textbf{csv} de manera nativa y desde otras fuentes (Excel, base de datos, etc.) usando librerías especiales:
 \begin{verbatim}
  my.frame<-read.table(file="edades.csv",header=T,sep=",")
 \end{verbatim}
\item El parámetro \verb+header+ específica si quiero usar la primera fila para asignarle nombres a las columnas.

\item Además R provee varias colecciones de datos para experimentar. Se pueden ver como el comando \verb+data()+.

\item Para ver todos los datasets disponibles de todas las librerías:
\begin{verbatim}
data(package = .packages(all.available = TRUE)) 
\end{verbatim}

\item Ahora podemos cargar un dataset, que se incluye como data.frame en mi workspace:
\begin{verbatim}
data(USArrests) # Arrestos en Estados Unidos por estado 
\end{verbatim}

 
\end{itemize}



}
\end{frame}



\begin{frame}[fragile]{Muestreo}
\scriptsize{
\begin{itemize}
 \item Cuando tenemos datasets muy grandes algunas técnicas estadísticas o de visualización pueden ser muy costosas computacionalmente.
 \item Se puede trabajar con una muestra aleatoria de los datos. 
 
 \item La idea es que si la muestra es representativa, la propiedades observadas serán equivalentes a las de la población.  
 
 \item En R se realiza el muestreo con el comando \textbf{sample}.
 
 \item Si la muestra es sin reemplazo, sacamos datos de manera aleatoria sin reponer el elemento. Entonces la muestra debe ser de menor tamaño que el dataset:

 \begin{verbatim}
> sample(edades,size=4,replace=F)
[1] 80 88 12 23
\end{verbatim}
\end{itemize}



}
\end{frame}


\begin{frame}[fragile]{Muestreo (2)}
\scriptsize{
\begin{itemize}
 \item Si la muestra es con reemplazo poddemos observar datos duplicados. De esta forma, la muestra puede ser incluso de mayor tamaño que la colección original: 

\begin{verbatim}
sample(edades,size=100,replace=T)
\end{verbatim}
 
 \item Cuando tenemos que los datos vienen etiquetados por alguna categoría y tomamos una muestra donde cada categoría tiene una participación proporcional a la de la colección original, tenemos un muestreo estratificado. 
 
 \item Ejercicio: extraer una muestra aleatoria sin reemplazo que tenga 10 filas del data.frame \textbf{USArrests}. \pause
 
 \begin{verbatim}
 USArrests[sample(1:(dim(USArrests)[1]),size=10,replace=F),]
 \end{verbatim}

\end{itemize}



}
\end{frame}






\begin{frame}[fragile]{Instalando librerías adicionales}
\scriptsize{
\begin{itemize}
 \item R tiene una comunidad muy activa que desarrolla muchas librerías para el análisis y la visualización de datos.
 \item Se pueden descargar librerías adicionales desde el repositorio CRAN directamente desde R.
 \item Las librerías se pueden instalar desde Rstudio o con el siguiente comando:
 \begin{verbatim}
 install.packages("rpart",dependencies=T)
\end{verbatim} 

\item Luego para poder usarlas se cargan de la siguiente forma: \verb+library(rpart)+.

\item Un conjunto de liberías muy útiles para manipular datos es \textit{tydyverse}:  \url{https://www.tidyverse.org/}.

 \begin{verbatim}
install.packages("tidyverse")
\end{verbatim} 


 
 \end{itemize}

 
}
 
\end{frame}




%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{frame}[allowframebreaks]\scriptsize
\frametitle{References}
\bibliography{bio}
\bibliographystyle{apalike}
%\bibliographystyle{flexbib}
\end{frame}  






%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
